<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]--><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Asciidoctor 1.5.6.1"><title>Bernard Teo Zhi Yi - Project Portfolio</title><link rel="stylesheet" href="../stylesheets/gh-pages.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../stylesheets/coderay-asciidoctor.css"></head><body class="article"><div id="site-header"><nav class="navbar navbar-light bg-light"><div class="container"><a class="navbar-brand" href="../index.html">DeadlineManager</a><ul class="navbar-nav"><li class="nav-item"><a class="nav-link" href="../UserGuide.html">User Guide</a></li><li class="nav-item"><a class="nav-link" href="../DeveloperGuide.html">Developer Guide</a></li><li class="nav-item"><a class="nav-link active" href="../AboutUs.html">About Us</a></li><li class="nav-item"><a class="nav-link" href="../ContactUs.html">Contact Us</a></li><li class="navitem"><a class="nav-link" href="https://github.com/CS2103-AY1819S1-W17-4/main"><span class="fa fa-github fa-lg" aria-hidden="true"></span>&nbsp;View on GitHub</a></li></ul></div></nav></div><div id="header"><h1>Bernard Teo Zhi Yi - Project Portfolio</h1></div><div id="content"><div class="sect1">
<h2 id="project-deadline-manager"><a class="link" href="#project-deadline-manager">PROJECT: Deadline Manager</a></h2>
<div class="sectionbody">
<hr>
</div>
</div>
<div class="sect1">
<h2 id="overview"><a class="link" href="#overview">Overview</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Deadline Manager is a desktop deadline manager application designed for students in NUS School of Computing.  It primarily uses a command line interface (CLI) and is optimized to be easy to use, but yet give users great control and flexibility.  It is written in Java and it builds upon AddressBook - Level 4, which was designed to teach software engineering principles.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary-of-contributions"><a class="link" href="#summary-of-contributions">Summary of contributions</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Major enhancement</strong>: added an <strong>expressive but terse way to filter tasks</strong></p>
<div class="ulist">
<ul>
<li>
<p>What it does: It allows the user to filter tasks using a filter expression.  Filter expressions can be composed from other filter expressions using "AND", "OR", and "NOT" logical operators, and users can optionally specify which attribute in the task to search against.</p>
</li>
<li>
<p>Justification: With an expected large number of tasks in our application, users need to be able to view a subset of tasks that are relevant to them so that they can make sense of their deadlines.  The ability to compose filter expressions adds great flexibility which is useful when filtering by more than one field.  The ability to export and share tasks further necessitates an expressive filter command that can filter precisely those tasks that the user would like to export.</p>
</li>
<li>
<p>Highlights: Firstly, the implementation features a full expression parser that parses arbitrary levels of parentheses and respects operator precedence.  Secondly, many different attribute of a tasks (of varying type, e.g. textual, numeric, date, sets) were made filterable.  Thirdly, each attribute could be compared in multiple ways (e.g. users can specify tasks to be filtered if they are due earlier than a given date, later than a given date, or exactly on a given date).  Fourthly, text can be quoted in order to search for a whole phrase.  Many design considerations have also been made to simplify its use: Specifying the attribute (of the task) for filtering is optional (when unspecified it searches all eligible attributes), a filter expression can use an attribute-specific default comparison, and "AND" operators may be omitted.  These design considerations greatly reduce the cognitive burden for simple use cases, but yet retain the ability to provide fine-grained control where needed.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Minor enhancement</strong>: added the deadline attribute to the task.</p>
<div class="ulist">
<ul>
<li>
<p>What it does: The deadline attribute contains the due date of the task, and this is essential to the core functionality of the deadline manager.</p>
</li>
<li>
<p>Highlights: The implementation deals with the parsing and validating of dates.  Furthermore, it integrates into other commands that need to specify a deadline.  This attribute was also integrated throughout the storage-related code so that the deadline can be exported to a file and imported into another instance of Deadline Manager.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Code contributed</strong>: <a href="https://github.com/CS2103-AY1819S1-W17-4/main/commits?author=btzy">Commits</a></p>
</li>
<li>
<p><strong>Other contributions</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Project management:</p>
<div class="ulist">
<ul>
<li>
<p>Contributed to user stories on GitHub issue tracker (<a href="https://github.com/CS2103-AY1819S1-W17-4/main/issues/9">#9</a>, <a href="https://github.com/CS2103-AY1819S1-W17-4/main/issues/9">#10</a>, <a href="https://github.com/CS2103-AY1819S1-W17-4/main/issues/9">#11</a>, <a href="https://github.com/CS2103-AY1819S1-W17-4/main/issues/9">#12</a>, <a href="https://github.com/CS2103-AY1819S1-W17-4/main/issues/9">#21</a>, <a href="https://github.com/CS2103-AY1819S1-W17-4/main/issues/9">#22</a>)</p>
</li>
<li>
<p>Manage milestones on GitHub</p>
</li>
</ul>
</div>
</li>
<li>
<p>Enhancements to existing features:</p>
<div class="ulist">
<ul>
<li>
<p>Overhauled the existing command parser to use a custom-made string tokenizer shared with the filter expression parser in order to support additional features such as quoted strings.  Almost all commands now depend on this string tokenizer.</p>
</li>
<li>
<p>Remove uniqueness constraints and weak equality in the underlying model.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Community:</p>
<div class="ulist">
<ul>
<li>
<p>Reviewed pull requests (with non-trivial review comments): <a href="https://github.com/CS2103-AY1819S1-W17-4/main/pull/92">#92</a>, <a href="https://github.com/CS2103-AY1819S1-W17-4/main/pull/154">#154</a></p>
</li>
<li>
<p>Contributed to forum discussions (examples:  <a href="https://github.com/nus-cs2103-AY1819S1/forum/issues/127">1</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributions-to-the-user-guide"><a class="link" href="#contributions-to-the-user-guide">Contributions to the User Guide</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Given below are sections I contributed to the User Guide. They showcase my ability to write documentation targeting end-users.</em></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="filtering-a-list-of-tasks-code-filter-code"><a class="link" href="#filtering-a-list-of-tasks-code-filter-code">Filtering a list of tasks: <code>filter</code></a></h3>
<div class="paragraph">
<p>Filters the current list of tasks with a specified filter expression.<br>
Format: <code>filter FILTER_EXPRESSION</code></p>
</div>
<div class="paragraph">
<p>When this command is used, Deadline Manager will display only those tasks which satisfy the given filter expression.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When executing any <em>modifying</em> commands on a filtered list, the filter will be removed after that command (so all tasks will be shown).  Modifying commands are those commands that modify the deadline manager&#8217;s content (e.g. <code>add</code>, <code>delete</code>, <code>edit</code> and <code>clear</code>).
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="overview-2"><a class="link" href="#overview-2">Overview</a></h4>
<div class="paragraph">
<p>Filter predicates are the core of the <code>filter</code> command.  Each filter predicate specifies a testable condition that, for every task, may evaluate to either <code>true</code> or <code>false</code> (e.g. whether the deadline is earlier than 1/10/2018).  Filter predicates are regarded as "indivisible".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Filter predicates are indivisible because each filter predicate represents a single rule for filtering - for example, a specified field (e.g. deadline) is compared against some specified value (e.g. 1/10/2018).  There is no way to decompose a filter predicate into smaller testable conditions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most of the time, the simplified filter syntax is sufficient to find the needed task(s).  However, when there are many tasks in the deadline manager and the simplified syntax returns too many results, or when an exact subset of tasks are required for exporting (see the <code>export</code> command), the simplified syntax becomes too imprecise to use.  For these use cases, the <code>filter</code> command also supports a fully-featured expression parser that is extremely expressive.</p>
</div>
</div>
<div class="sect3">
<h4 id="simplified-filter-syntax"><a class="link" href="#simplified-filter-syntax">Simplified filter syntax</a></h4>
<div class="paragraph">
<p>Tasks can be filtered by typing <code>filter</code> followed by one or more space-separated keywords (e.g. <code>filter homework</code>, <code>filter assignment CS2103</code>, or <code>filter badminton utown 3/10/2018</code>).  Such a filter expression would display only those tasks that contain textual or date fields (i.e. name, deadline, tags, and attachments) that matches <strong>every</strong> keyword (e.g. <code>filter assignment CS2103</code> will match a task with name <code>Assignment 1</code> <strong>and</strong> tags <code>CS2103</code> and <code>easy</code>).</p>
</div>
<div class="paragraph">
<p>Numeric fields such as priority and frequency are not matched because the integer values used for priority and frequency often match many task names and tags too.  To filter by priority and frequency, the field must be specified explicitly (see the section on <em>Controlling the field being matched</em> below).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An unquoted keyword can contain only alphanumeric characters, <code>_</code>, <code>-</code>, <code>/</code>, <code>\</code>, <code>.</code>, and <code>,</code>.  To use other characters (including whitespace), the keyword must be placed in quotes (both single (<code>'</code>) and double (<code>"</code>) quotes work, but the opening and closing quotes must match).
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Matching of each eligible field:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When matching task names, a task is considered to match if the specified keyword is a substring (case-insensitive) of the task name (the given keyword need not be a whole word in the task name - e.g. <code>test</code> and <code>case</code> will both match <code>Testcase</code>).</p>
</li>
<li>
<p>When matching deadlines, a task is considered to match if its deadline is on or earlier than the specified date.</p>
</li>
<li>
<p>When matching tags, a task is considered to match if the specified tag is a substring (case-insensitive) of any tag of the task.</p>
</li>
<li>
<p>When matching attachments, a task is considered to match if the specified keyword is a substring (case-insensitive) of a filename of any attachment in the task.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter homework</code>
Returns a subset of the current list of tasks that have a name or tag list that contains "homework".  Note that "homework" cannot be interpreted as a valid date, so the deadline field is ignored.</p>
</li>
<li>
<p><code>filter assignment CS2103</code>
Returns a subset of the current list of tasks that have a name or tag list that contains "assignment" and a name or tag list that contains "CS2103".  Note that neither "assignment" or "CS2103" can be interpreted as a valid date, so the deadline field is ignored for both keywords.</p>
</li>
<li>
<p><code>filter badminton utown 3/10/2018</code>
Returns a subset of the current list of tasks that have a name or tag list that contains "badminton", a name or tag list that contains "utown", and a name, tag list, or deadline that matches "3/10/2018".  Note that any deadline on or before 3 October 2018 will match "3/10/2018".</p>
</li>
<li>
<p><code>filter 1/10/2018</code>
Returns a subset of the current list of tasks that have a name, tag list, or deadline on or before 1st October 2018.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="controlling-the-field-being-matched"><a class="link" href="#controlling-the-field-being-matched">Controlling the field being matched</a></h4>
<div class="paragraph">
<p>Each keyword can instead be written as a <em>full predicate</em>, which is a string of the following format: <code>&lt;key&gt;&lt;operator&gt;&lt;phrase&gt;</code>. The following diagram is an example of a typical full predicate:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FilterUnitDiagramUG.png" alt="FilterUnitDiagramUG" width="200">
</div>
</div>
<div class="paragraph">
<p>Each of the three parts of a full predicate means the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>key</code> is an alphabetic string that describes the attribute being compared. For example: <code>priority</code>, <code>tag</code> and <code>name</code>.</p>
</li>
<li>
<p><code>operator</code> is one of <code>:</code>, <code>=</code>, <code>&lt;</code>, <code>&gt;</code>.</p>
</li>
<li>
<p><code>phrase</code> is a string that describes what to search (this is called the search phrase, and it is similar to the <em>keyword</em> in the simplified syntax).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As with the simplified syntax, an unquoted <code>phrase</code> string can contain only alphanumeric characters, <code>_</code>, <code>-</code>, <code>/</code>, <code>\</code>, <code>.</code>, and <code>,</code>.  To use other characters (including whitespace), the search phrase must be placed in quotes (both single (<code>'</code>) and double (<code>"</code>) quotes work, but the opening and closing quotes must match).</p>
</div>
<div class="paragraph">
<p>The operator <code>:</code> is known as the <strong>convenience</strong> operator&#8201;&#8212;&#8201;it is an alias for the operator that intuitively "does what you expect" for the given <code>key</code>.  More details are given below in the context of each key.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>&lt;</code> and <code>&gt;</code> operators are non-strict: Every task that will be shown using <code>=</code> will also be shown using <code>&lt;</code> or <code>&gt;</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This full predicate syntax can be mixed arbitrary with the keyword syntax described in the previous section.  For example, <code>badminton n:utown 3/10/2018</code> is allowed.
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Meaning of the operators for each valid key:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When <code>key</code> is <code>n</code> or <code>name</code>, the task name is compared.  Comparison is case-insensitive.  The operator <code>&gt;</code> tests if the search phrase is contained within the task name.  The operator <code>&lt;</code> tests if the task name is contained within the search phrase.  The operator <code>=</code> tests if the search phrase is exactly the same as the task name.  The convenience operator is an alias for <code>&gt;</code>.</p>
</li>
<li>
<p>When <code>key</code> is <code>d</code>, <code>due</code> or <code>deadline</code>, the task&#8217;s due date is compared, and the search phrase is interpreted as a date.  Dates must be in <code>d/m/y</code> format.  The operator <code>&gt;</code> tests if the task&#8217;s due date is on or after the specified due date.  The operator <code>&lt;</code> tests if the task&#8217;s due date is on or before the specified due date.  The operator <code>=</code> tests if the task&#8217;s due date is exactly equal to the specified due date.  The convenience operator is an alias for <code>&lt;</code>.</p>
</li>
<li>
<p>When <code>key</code> is <code>p</code> or <code>priority</code>, the task&#8217;s priority is compared, and the search phrase is interpreted as an integer, representing the priority to be searched.  A priority of zero matches all the tasks with no priority set.  The operator <code>&gt;</code> tests if the task has priority at least as high as the specified priority.  The operator <code>&lt;</code> tests if the task has priority at most as high as the specified priority.  The operator <code>=</code> tests if the task&#8217;s priority is exactly equal to the specified priority.  The convenience operator is an alias for <code>&gt;</code>.  Note that priority 1 is the highest priority, priority 4 is the lowest priority, and tasks without any priority are considered to be of lower priority than priority 4.  In other words, <code>1 &gt; 2 &gt; 3 &gt; 4 &gt; (no priority)</code>.</p>
</li>
<li>
<p>When <code>key</code> is <code>f</code> or <code>frequency</code>, the task&#8217;s frequency (i.e. the number of days between consecutive occurrences of that task) is compared, and the search phrase is interpreted as an integer, representing the frequency to be searched.  A non-recurring task is treated as if it has a frequency that is infinitely large (i.e. <code>f&gt;100</code> also includes all non-recurring tasks).  The operator <code>&gt;</code> tests if the task has a recurrence interval larger than or equal to the specified number of days.  The operator <code>&lt;</code> tests if the task has a recurrence interval smaller than or equal to the specified number of days.  The operator <code>=</code> tests if the task has a recurrence interval exactly equal to the specified number of days.  The convenience operator is an alias for <code>&lt;</code>.</p>
</li>
<li>
<p>When <code>key</code> is <code>t</code> or <code>tag</code>, the task&#8217;s tags are compared, and the search phrase is interpreted as a (unordered) set of (substrings of) tags.  Comparison is case-insensitive.  Multiple tags are separated by commas (see examples below).  The operator <code>&gt;</code> tests if every specified tag is a substring of a tag of the given task.  The operator <code>&lt;</code> tests if every specified tag is a superstring of a tag of the given task.  The operator <code>=</code> tests if every specified tag exactly matches a tag of the given task.  The convenience operator is an alias for <code>&gt;</code>.</p>
</li>
<li>
<p>When <code>key</code> is <code>a</code> or <code>attachment</code>, the task&#8217;s attachments are compared, and the search phrase is interpreted as a (unordered) set of (substrings of) filenames.  Comparison is case-insensitive.  Multiple filenames are separated by commas, in the same way as tags.  The operator <code>&gt;</code> tests if every specified filename is a substring of an attachment filename (of the given task).  The operator <code>&lt;</code> tests if every specified tag is a superstring of an attachment filename.  The operator <code>=</code> tests if every specified tag exactly matches an attachment filename.  The convenience operator is an alias for <code>&gt;</code>.</p>
</li>
<li>
<p>Any other <code>key</code> will cause Deadline Manager to produce an error.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For set-based filter predicates (i.e. tags and attachments), an extension is available to specify that the set of tags (or attachments) in the task must be <em>exactly</em> those tags (or attachments) in the filter predicate (i.e. there should be no extra tags (or attachments) in the task).  See the <em>Set-based extensions for filter predicates</em> section for more details.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The behaviour of the simplified syntax mirrors that of the convenience operator.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter due&lt;1/10/2018</code>
Returns a subset of the current list of tasks that have deadlines on or before 1st October 2018.</p>
</li>
<li>
<p><code>filter d=1/10/2018</code>
Returns a subset of the current list of tasks that have deadlines equal to 1st October 2018.</p>
</li>
<li>
<p><code>filter d:1/10/2018</code>
Returns a subset of the current list of tasks that have deadlines on or before 1st October 2018.</p>
</li>
<li>
<p><code>filter name:Alex</code>
Returns a subset of the current list of tasks that have a name that contains "Alex" (case-insensitive).</p>
</li>
<li>
<p><code>filter n:"Alex Tan"</code>
Returns a subset of the current list of tasks that have a name that contains "Alex Tan" (case-insensitive).</p>
</li>
<li>
<p><code>filter p=1</code>
Returns a subset of the current list of tasks that have priority = 1 (highest priority).</p>
</li>
<li>
<p><code>filter p&gt;3</code>
Returns a subset of the current list of tasks that have priority = 1, 2, or 3. (Highest priority, second highest priority, or third highest priority.)</p>
</li>
<li>
<p><code>filter f=1</code>
Returns a subset of the current list of tasks that recurs daily.</p>
</li>
<li>
<p><code>filter f&lt;7</code>
Returns a subset of the current list of tasks that recurs at least once a week.</p>
</li>
<li>
<p><code>filter t:CS</code>
Returns a subset of the current list of tasks that has a tag that contains the substring "CS" (case-insensitive).  The task could also contain other tags.</p>
</li>
<li>
<p><code>filter t=CS2103T</code>
Returns a subset of the current list of tasks that has the tag "CS2103T" (case-insensitive).  The task could also contain other tags.</p>
</li>
<li>
<p><code>filter t=CS2103T,CS2101</code>
Returns a subset of the current list of tasks that has both the tags "CS2103T" and "CS2101" (case-insensitive).  The task could also contain other tags.</p>
</li>
<li>
<p><code>filter a:hello</code>
Returns a subset of the current list of tasks that contains an attachment with a filename that contains "hello" (case-insensitive).  The task could also contain other attachments.</p>
</li>
<li>
<p><code>filter a=Test.java,'Hello world.txt'</code>
Returns a subset of the current list of tasks that contains the attachments with exact filenames "Test.java" and "Hello world.txt" (case-insensitive).  The task could also contain other attachments.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="composing-filter-predicates"><a class="link" href="#composing-filter-predicates">Composing filter predicates</a></h4>
<div class="paragraph">
<p>In the simplified filter syntax, multiple space-separated keywords mean that <em>every</em> keyword must match some field in the task, effectively expressing a logical conjunction (i.e. AND).  To allow for full flexibility, logical disjunction (i.e. OR), logical negation (i.e. NOT), and arbitrary compositions of logical operations may also be expressed, and they are described below:</p>
</div>
<div class="paragraph">
<p>Filter expressions (i.e. the <code>FILTER_EXPRESSION</code> strings) are composed from any number of filter predicates, and they create a composite rule to filter against.  The <code>filter</code> command is designed to accept arbitrarily complex filter expressions that can be composed from any number of filter predicates.<br>
The format for <code>FILTER_EXPRESSION</code> is defined recursively in the following paragraphs.</p>
</div>
<div class="paragraph">
<p><code>FILTER_EXPRESSION</code> is a string in the following format:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FILTER_PREDICATE</code>&#8201;&#8212;&#8201;This filter expression contains a single filter predicate (each filter predicate can use either the full predicate or the keyword syntax)</p>
</li>
<li>
<p><code>FILTER_EXPRESSION &amp; FILTER_EXPRESSION</code>&#8201;&#8212;&#8201;This filter expression is a logical conjunction (i.e. AND) of two other filter expressions.  The operator <code>&amp;</code> may be substituted with <code>&amp;&amp;</code>.</p>
</li>
<li>
<p><code>FILTER_EXPRESSION | FILTER_EXPRESSION</code>&#8201;&#8212;&#8201;This filter expression is a logical disjunction (i.e. OR) of two other filter expressions.  The operator <code>|</code> may be substituted with <code>||</code>.</p>
</li>
<li>
<p><code>! FILTER_EXPRESSION</code>&#8201;&#8212;&#8201;This filter expression is a logical negation (i.e. NOT) of two other filter expressions.</p>
</li>
<li>
<p><code>( FILTER_EXPRESSION )</code>&#8201;&#8212;&#8201;This filter expression is surrounded by parentheses.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Parentheses are used for finer control the order that filter expressions are combined.  By default, <code>!</code> has highest precedence (i.e. <code>!</code> is applied first), followed by <code>&amp;</code>, then followed by <code>|</code>.  Parentheses may be nested to arbitrary depth, and in any valid manner.</p>
</div>
<div class="paragraph">
<p>When no boolean operator (<code>&amp;</code>, <code>|</code>, or <code>!</code>) is specified where one is expected, it is implicitly treated as if an <code>&amp;</code> was used.  This allows the simplified syntax to work as it currently does.</p>
</div>
<div class="paragraph">
<p>When it is unambiguous, whitespace between the operators and filter expressions may be omitted.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Intuitively, the syntax for filter expressions mirrors that of arithmetic expressions such as <code>1+3*4</code> and <code>(1+4+6)*2</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter assignment|CS2101</code>
Returns a subset of the current list of tasks that have a name or tag list that contains "assignment" or "CS2101".</p>
</li>
<li>
<p><code>filter ! t:CS2101</code>
Returns a subset of the current list of tasks that do not have the tag "CS2101".</p>
</li>
<li>
<p><code>filter n:assignment | (p:3 &amp; t:CS2101)</code>
Returns a subset of the current list of tasks that have a name that contains "assignment", or have priority at least 3 and contains tag "CS2101".</p>
</li>
<li>
<p><code>filter n:assignment||(p:3 t:CS2101)</code>
Returns a subset of the current list of tasks that have a name that contains "assignment", or have priority at least 3 and contains tag "CS2101".</p>
</li>
<li>
<p><code>filter !n:homework||(p:3 t:CS2101)</code>
Returns a subset of the current list of tasks that have a name that does not contain "homework", or have priority at least 3 and contains tag "CS2101".</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="set-based-extensions-for-filter-predicates"><a class="link" href="#set-based-extensions-for-filter-predicates">Set-based extensions for filter predicates</a></h4>
<div class="paragraph">
<p>For fields that represent a collection (i.e. tags and attachments), it is also possible to filter only tasks which <strong>do not contain</strong> other tags or attachments apart from those specified.  To do so, we introduce a set operator as per the diagram below:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FilterUnitDiagramSetUG.png" alt="FilterUnitDiagramSetUG" width="200">
</div>
</div>
<div class="paragraph">
<p>The part that was called <code>operator</code> previously is called the <code>field operator</code> here, and it retains its original meaning.  The <code>set operator</code> introduced here specifies how the specified set (in the filter predicate) compares to the task&#8217;s set (of tags or attachments).</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Meaning of the set operator:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The operator <code>&gt;</code> tests if every item in the specified set is contained within the task&#8217;s set.  The operator <code>&lt;</code> tests if every item in the task&#8217;s set is contained within the specified set.  The operator <code>=</code> tests if the two sets are equivalent (meaning that every item in the task&#8217;s set is contained within the specified set and vice-versa).  The convenience operator is an alias for <code>&gt;</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When comparing a set-based field without using this dual-operator syntax, the set based operator used is effectively the convenience operator.  (In other words, <code>&lt;key&gt;&lt;operator&gt;&lt;phrase&gt;</code> is equivalent to <code>&lt;key&gt;:&lt;operator&gt;&lt;phrase&gt;</code>.)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter t=:CS</code>
Returns a subset of the current list of tasks that has a tag that contains the substring "CS" (case-insensitive).  The task cannot contain any tags that do not have the substring "CS".</p>
</li>
<li>
<p><code>filter a=:Hello</code>
Returns a subset of the current list of tasks that has an attachment that contains the substring "Hello" (case-insensitive).  The task cannot contain any attachments that do not have the substring "Hello".</p>
</li>
<li>
<p><code>filter t==CS2103T,CS2101</code>
Returns a subset of the current list of tasks that has both the tags "CS2103T" and "CS2101" (case-insensitive).  The task cannot contain any other tags.</p>
</li>
<li>
<p><code>filter t:=CS2103T</code>
Returns a subset of the current list of tasks that has the tag "CS2103T" (case-insensitive).  The task could also contain other tags.  (This is equivalent to <code>filter t=CS2103T</code>.)</p>
</li>
<li>
<p><code>filter t&lt;:CS</code>
Returns a subset of the current list of tasks that do not have any tags that do not contain the substring "CS" (case-insensitive).  The task need not have any tags that contain the substring "CS", and it could have no tags at all.  This is usually used in conjunction with other filter predicates to constrain the filtered list to be exported.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributions-to-the-developer-guide"><a class="link" href="#contributions-to-the-developer-guide">Contributions to the Developer Guide</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Given below are sections I contributed to the Developer Guide. They showcase my ability to write technical documentation and the technical depth of my contributions to the project.</em></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="filter-feature"><a class="link" href="#filter-feature">Filter feature</a></h3>
<div class="paragraph">
<p>The deadline manager supports a very expressive filtering system.  The filtering system can be utilized with the <code>filter</code> command.</p>
</div>
<div class="paragraph">
<p>The filtering system is designed with two primary goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Expressiveness: Complex ways of filtering tasks can be expressed in the command format and be understood by the program.</p>
</li>
<li>
<p>Terseness: The amount of user input required to express a filter is as little as possible.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="overview-3"><a class="link" href="#overview-3">Overview</a></h4>
<div class="paragraph">
<p>When a user invokes the <code>filter</code> command (e.g. <code>filter t:CS2101 &amp; n:Assignment</code>), the following steps are taken by the program:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Extract the text describing the filter operation (e.g. <code>t:CS2101 &amp; n:Assignment</code>)</p>
</li>
<li>
<p>Parse the text describing the filter operation into a predicate (i.e. <code>Predicate&lt;Task&gt;</code>)</p>
</li>
<li>
<p>Apply the predicate on the model (this simply calls <code>Model#updateFilteredPersonList()</code>, which internally leverages on JavaFX&#8217;s <code>FilteredList</code> class to provide filtering by predicate)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Step 1 is performed by the <code>AddressBookParser</code> class, and no special actions need to be taken by the filtering system.</p>
</div>
<div class="paragraph">
<p>Step 3 is performed by the <code>FilterCommand</code> class.  It is a simple operation that simply delegates the task to <code>Model#updateFilteredPersonList()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When executing any <em>modifying</em> commands on a filtered list, the filter will be removed after that command (so all tasks will be shown).  Modifying commands are those commands that modify the deadline manager&#8217;s content (e.g. <code>add</code>, <code>delete</code>, <code>edit</code> and <code>clear</code>).  This design decision has been made because modifying a task might cause a task to no longer remain satisfy a filter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The overwhelming majority of code for the filtering system comes from step 2, which is performed by the <code>FilterCommandParser</code> class.  The ability to parse complex filter descriptions into usable predicates forms the core of the filtering feature, and this ability makes the filtering system very flexible.</p>
</div>
<div class="paragraph">
<p>In the rest of this guide that describes the filtering system, we use the term <em>filter expression</em> to refer to the full filter operation that the user typed (e.g. <code>t:CS2101 &amp; n:Assignment</code>, or even <code>t:CS2101 &amp; ( n:Assignment | n:Homework) &amp; p&lt;3</code>), and the term <em>filter unit</em> to refer to substrings of the filter expression that represent single indivisible predicates (e.g. <code>t:CS2101</code>, or <code>n:Homework</code>).</p>
</div>
<div class="paragraph">
<p>There are four components to parsing the filter operation:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A boolean expression parser that understands the high-level syntax of the filter expression and digests the filter expression into filter units</p>
</li>
<li>
<p>A parser that splits each filter unit (e.g. <code>t:CS2101</code>) into its three (or four) constituent parts if possible (e.g. <code>t</code>, <code>:</code>, <code>CS2101</code>)&#8201;&#8212;&#8201;this is the lambda expression in the sequence diagram below, which resides in the <code>FilterCommandParser</code> class</p>
</li>
<li>
<p>A parser that splits set-based fields (e.g. <code>CS2101,CS2103</code>) into individual keywords (this applies only to set-based fields (tags and attachments))&#8201;&#8212;&#8201;this is referred to as the <em>set parser</em>, and is implemented as a static method in a utility class</p>
</li>
<li>
<p>A method for each field (e.g. <code>Name</code>, <code>Deadline</code>, <code>Priority</code>, <code>Tag</code>) that interprets the the parts of the splitted filter unit in the context of that particular field, and returns the predicate that is required &#8201;&#8212;&#8201;this is referred to as the <em>field-specific parser</em>, and is implemented as a static method in each filterable field</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The second component in the list above also accepts a filter unit that contains the third part alone (e.g. <code>CS2101</code>) without the other two parts&#8201;&#8212;&#8201;this is known as the <em>simplified filter unit syntax</em>.  Also, when filtering by a set-based field, the filter unit can be splitted into four parts instead of three (e.g. <code>t=:CS2101,CS2103</code> will be plitted as <code>t</code>, <code>=</code>, <code>:</code>, <code>CS2101,CS2103</code>), and the additional symbol (<code>=</code> in this case) is used to specify how sets are compared.  These will be explained in more detail below.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A general string tokenizer (this is the <code>StringTokenizer</code> class in the <code>parser</code> subdirectory) is shared by parts 1 and 2 to split the filter expression into tokens.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FilterOperationSequenceDiagram.png" alt="FilterOperationSequenceDiagram" width="800">
</div>
</div>
<div class="paragraph">
<p>The above diagram shows the simplified sequence of operations to parse a filter expression into a predicate for non-set-based fields.  Take note of the following simplifications in the sequence diagram above:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>"Field" represents any filterable field&#8201;&#8212;&#8201;<code>Name</code>, <code>Deadline</code>, <code>Priority</code>, or <code>Frequency</code>.</p>
</li>
<li>
<p>Strictly speaking, the "loop" is not actually a loop.  As the boolean expression parser parses the filter expression, it invokes the lambda expression whenever a filter unit is encountered.  For simplicity, the sequence diagram above hides the complexity within the boolean expression parser.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Set-based fields are described in the <em>Set parser</em> section.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The sections below describe the string tokenizer and the aforementioned four components in more detail.</p>
</div>
</div>
<div class="sect3">
<h4 id="string-tokenizer"><a class="link" href="#string-tokenizer">String tokenizer</a></h4>
<div class="paragraph">
<p>This is represented by the class <code>seedu.address.logic.parser.tokenizer.StringTokenizer</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This class is not to be confused with <code>java.util.StringTokenizer</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This class is initialized with the whole filter expression, and can be queried for a token multiple times&#8201;&#8212;&#8201;each query consumes and returns the next available token, in a similar way to <code>java.util.Scanner</code>.</p>
</div>
<div class="paragraph">
<p>There are two ways to consume tokens using the string tokenizer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Consume a text string.  This is used for consuming tokens that are intended to be textual (e.g. <code>t</code>, <code>CS2101</code>).  Consumption of text strings is quote-aware&#8201;&#8212;&#8201;if the text string is quoted using single or double quotes, the text string would be consumed as a single token, even if it contains spaces or special characters.  This is useful when the user wants to search for a name that contains those characters.</p>
</li>
<li>
<p>Consume a token by a regular expression.  This is used for consuming symbolic tokens (e.g. <code>:</code>, <code>|</code>, <code>&amp;</code>, <code>(</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When unambiguous, adjacent tokens need not be separated by whitespace.  This is usually the case when consuming a token specified by a regular expression.  This works because when consuming a token, it is often possible to know where the token ends even in the absense of whitespace (e.g. when encountering a matching closing quote or an operator symbol).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>StringTokenizer</code> class is also used in two other places&#8201;&#8212;&#8201;in the <code>ArgumentTokenizer</code> class to tokenize arguments specified in the usual syntax for most other commands (e.g. <code>add n/Assignment 2 d/1/1/2018 p/1</code>), and in the <code>SetUtil</code> class to parse comma-separated set-based filter expressions (i.e. tags and attachments).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="boolean-expression-parser"><a class="link" href="#boolean-expression-parser">Boolean expression parser</a></h4>
<div class="paragraph">
<p>This is represented by the generic class <code>seedu.address.logic.parser.tokenizer.BooleanExpressionParser&lt;T&gt;</code>, and it is a general boolean expression parser that is designed to be unaware of the syntax of individual filter units.</p>
</div>
<div class="paragraph">
<p>The following operators are recognized (highest precedence first):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>!</code>: Logical negation (NOT) of two predicates</p>
</li>
<li>
<p><code>&amp;</code> or <code>&amp;&amp;</code>: Logical conjunction (AND) of two predicates</p>
</li>
<li>
<p><code>|</code> or <code>||</code>: Logical disjunction (OR) of two predicates</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Parentheses (<code>(</code> and <code>)</code>) are also recognized and respected, and they may be nested to arbitrary depth.  When two predicates are adjacent, the <code>&amp;</code> operator is inserted between them.  This allows for simpler filter expressions (especially when combined with the simplified filter unit syntax).</p>
</div>
<div class="paragraph">
<p>The boolean expression parser uses the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting yard algorithm</a> to provide precedence-respecting parsing of the filter expression.</p>
</div>
<div class="paragraph">
<p>The boolean expression parser functions as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The boolean expression parser is constructed with the filter expression, and it constructs a <code>StringTokenizer</code> instance from the given filter expression.</p>
</li>
<li>
<p>When the start of an operand (i.e. filter unit) is encountered, it hands over the <code>StringTokenizer</code> instance to the filter unit parser (this is defined in the <code>FilterCommandParser</code> class).  The filter unit parser determines the field name, and then uses the field-specific parser to construct the predicate (i.e. <code>Predicate&lt;Task&gt;</code> instance) that the filter unit represents.  This predicate is returned to the boolean expression parser.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Application of operators (i.e. <code>!</code>, <code>&amp;</code>, <code>|</code>) is done by the boolean expression parser itself (i.e. without delegating the work to other classes).</p>
</div>
</div>
<div class="sect3">
<h4 id="filter-unit-parser"><a class="link" href="#filter-unit-parser">Filter unit parser</a></h4>
<div class="paragraph">
<p>The filter unit parser is written as a lambda expression inside the <code>FilterCommandParser</code> class.  There are two reasons for this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The filter unit parser parses syntax that is specific to filters only, and it cannot be easily adapted for other uses.</p>
</li>
<li>
<p>It frees both the boolean expression parser and the field-specific parser from having to depend on the <code>FilterCommandParser</code> class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are three possible ways to express a filter unit:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The full syntax&#8201;&#8212;&#8201;this allows for specifying the field for comparison and the method of comparison to be used</p>
</li>
<li>
<p>The extended full syntax for sets&#8201;&#8212;&#8201;this is like the full syntax, but enhanced with a way to specify how to compare sets</p>
</li>
<li>
<p>The simplified syntax&#8201;&#8212;&#8201;this improves terseness and reduces cognitive overhead</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following diagram is describes a filter unit that is specified using the full syntax:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FilterUnitDiagram.png" alt="FilterUnitDiagram" width="200">
</div>
</div>
<div class="paragraph">
<p>The following diagram is describes a filter unit that is specified using the extended full syntax for sets:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FilterUnitDiagramSet.png" alt="FilterUnitDiagramSet" width="250">
</div>
</div>
<div class="paragraph">
<p>As shown in the diagram above, a filter unit (using the full syntax or extended syntax) consists of these parts:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The field identifier, which identifies the field (e.g. name or deadline) that is being filtered on</p>
</li>
<li>
<p>The test phrase, which represents the value or keyword that tasks are being compared to</p>
</li>
<li>
<p>The filter operator, which describes how the identified field is compared to the test phrase (for set-based fields, this describes how each item (tag or attachment) in the identified field is compared to each item in the test phrase) (more details below)</p>
</li>
<li>
<p>(For the extended syntax only) The set operator, which describes the how the set of items (tags or attachments) in the identified field is compared to the set of items in the test phrase, when regarded as a set (more details below)</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The simplified syntax only contains the test phrase, and is explained in a separate section below.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A non-quoted test phrase only allows alphanumeric characters and the characters <code>_</code>, <code>-</code>, <code>/</code>, and <code>,</code>.  (The <code>/</code> character allows dates to work, and the <code>,</code> character allows tag lists to work.)  The string tokenizer provides the bindings to facilitate this check.  If other characters are required, then the test phrase must be placed in quotes (either single or double quotes are acceptable, but they must match).</p>
</div>
<div class="paragraph">
<p>These three parts are described in the following sections.</p>
</div>
<div class="sect4">
<h5 id="field-identifier"><a class="link" href="#field-identifier">Field identifier</a></h5>
<div class="paragraph">
<p>There are six filterable fields in a task, and each of these fields correspond to two or more field identifiers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>n</code> or <code>name</code>&#8201;&#8212;&#8201;the name of the task</p>
</li>
<li>
<p><code>d</code>, <code>due</code> or <code>deadline</code>&#8201;&#8212;&#8201;the deadline (i.e. due date) of the task</p>
</li>
<li>
<p><code>p</code> or <code>priority</code>&#8201;&#8212;&#8201;the priority of the task</p>
</li>
<li>
<p><code>f</code> or <code>frequency</code>&#8201;&#8212;&#8201;the frequency of the task (in days)</p>
</li>
<li>
<p><code>t</code> or <code>tag</code>&#8201;&#8212;&#8201;the set of tags associated with the task</p>
</li>
<li>
<p><code>a</code> or <code>attachment</code>&#8201;&#8212;&#8201;the set of attachments associated with the task</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Field identifiers that correspond to the same field are equivalent.</p>
</div>
</div>
<div class="sect4">
<h5 id="test-phrase"><a class="link" href="#test-phrase">Test phrase</a></h5>
<div class="paragraph">
<p>This is the value or keyword that tasks are compared to, and the syntax of this field depends on the field identifier of this filter unit.</p>
</div>
<div class="paragraph">
<p>The following is the required syntax for each filterable field:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Name: Any text string</p>
</li>
<li>
<p>Deadline: Any date in the form <code>DD/MM/YYYY</code></p>
</li>
<li>
<p>Priority: Any valid priority value (i.e. any integer between 0 and 4 inclusive)</p>
</li>
<li>
<p>Frequency: Any valid frequency value (i.e. any non-negative integer that does not exceed the maximum bounds of an integer)</p>
</li>
<li>
<p>Tag set: Any comma-separated list of tags, where each tag can be any text string (e.g. <code>CS2101,CS2103T</code>)</p>
</li>
<li>
<p>Attachment set: Any comma-separated list of attachments, where each attachment can be any text string (e.g. <code>helloworld.txt,Main.java</code>)</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The rules for quoted strings for the string tokenizer applies here as well, because the same string tokenizer is used here.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Set-based fields that contain spaces may be specified by placing quotes around those the item with spaces.  This means that the whole test phrase must also be quoted with a different type of quote (e.g. <code>t:"CS2101,CS2103T,'Oral Presentation'"</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="filter-operator"><a class="link" href="#filter-operator">Filter operator</a></h5>
<div class="paragraph">
<p>The filter operator specifies exactly <em>how</em> the task should be compared to the test phrase.</p>
</div>
<div class="paragraph">
<p>For fields that are intrinsically ordered (i.e. deadline, priority and frequency), the <code>&lt;</code>, <code>=</code>, and <code>&gt;</code> operators have their usual mathematical meaning, except that the operators <code>&lt;</code> and <code>&gt;</code> are non-strict.  This means that <code>p&gt;2</code> will return a superset of the tasks returned by <code>p=2</code>.</p>
</div>
<div class="paragraph">
<p>For textual fields (e.g. name, tag), the <code>&lt;</code>, <code>=</code>, <code>&gt;</code> operators represent <em>substring</em>, <em>equivalence</em>, and <em>superstring</em> relations respectively.</p>
</div>
<div class="paragraph">
<p>As most users do not usually require such fine-grained control over the filter operator, the <code>:</code> operator, known as the <em>convenience</em> operator, is provided as well.  The convenience operator is an alias for one of the other filter operators, and the choice of filter operator depends on the field identifier.  For each field, the filter operator that is expected to be most commonly used is chosen as the target for the convenience operator.</p>
</div>
<div class="paragraph">
<p>The following list shows what the convenience operator means, in the context of each field:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Name: <code>:</code> is an alias for <code>&gt;</code></p>
</li>
<li>
<p>Deadline: <code>:</code> is an alias for <code>&lt;</code></p>
</li>
<li>
<p>Priority: <code>:</code> is an alias for <code>&gt;</code></p>
</li>
<li>
<p>Frequency: <code>:</code> is an alias for <code>&lt;</code></p>
</li>
<li>
<p>Tag set: <code>:</code> is an alias for <code>&gt;</code></p>
</li>
<li>
<p>Attachment set: <code>:</code> is an alias for <code>&gt;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="set-operator"><a class="link" href="#set-operator">Set operator</a></h5>
<div class="paragraph">
<p>Set-based fields can specify an additional level of comparison - how the task&#8217;s set compares with the specified set.  It is distinct from the filter operator because the filter operator is used to compare each individual item in the set (in the context of the given field), while the set operator is used to compare at the set level (which is same regardless of which field is being compared).</p>
</div>
<div class="paragraph">
<p>For set-based fields (e.g. tags), the filter unit parser does not invoke the field-specific parser directly.  Instead, control goes through the set parser, which is described in the <em>Set parser</em> section below.</p>
</div>
</div>
<div class="sect4">
<h5 id="simplified-filter-unit-syntax"><a class="link" href="#simplified-filter-unit-syntax">Simplified filter unit syntax</a></h5>
<div class="paragraph">
<p>The simplified filter unit syntax elides the field identifier and the filter operator.  A filter unit (specified with the simplified syntax) is tested against all <em>eligible</em> fields.</p>
</div>
<div class="paragraph">
<p>All textual and date fields are <em>eligible</em>.  This means that the name, deadline, tags, and attachments fields are tested against when the simplified syntax is used.  Numeric fields (i.e. priority and frequency) are omitted because they often inadvertently match a test phrase (e.g. when the user attempts to search for tasks which have a name or tag that contains numbers).</p>
</div>
<div class="paragraph">
<p>Each eligible field is compared as if using the convenience operator (for both the filter operator and set operator, if necessary).  A match in <em>any</em> eligible field of a task will cause the task to match this filter unit.  Errors in interpreting the test phrase in the context of a field are simply treated as a non-match of the field instead of a hard error (e.g. the test phrase <code>Assignment</code> cannot be interpreted as a deadline, so the deadline field will be skipped when attempting to match this test phrase).</p>
</div>
<div class="paragraph">
<p>As with the full syntax, the simplified syntax supports quoting the test phrase if special characters are required.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="set-parser"><a class="link" href="#set-parser">Set parser</a></h4>
<div class="paragraph">
<p>The set parser tokenizes the given test phrase, and feeds each item into the field-specific parser separately.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;</code>, <code>=</code>, <code>&gt;</code> set operators represent <em>subset</em>, <em>equivalence</em>, and <em>superset</em> relations respectively.  Each individual item is compared using the specified filter operator as specified in the previous <em>Filter operator</em> section.</p>
</div>
<div class="paragraph">
<p>Just like the filter operator, there is a convenience set operator (<code>:</code>), and it is an alias for <code>&gt;</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The set operator is orthogonal to the filter operator, and hence they may be combined in any way.  Furthermore, when the set operator is omitted for a set-based field, the convenience set operator is implied.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The set parser is implemented in the <code>makeFilter()</code> method of the <code>seedu.address.model.util.SetUtil</code> class.  It parses the comma-separated list (i.e. the test phrase) using a new instance of <code>StringTokenizer</code>, and then uses reflection to invoke the relevant field-specific parser for each item in the comma-separated list.  This is illustrated in the sequence diagram below:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FilterOperationSequenceDiagramSet.png" alt="FilterOperationSequenceDiagramSet" width="800">
</div>
</div>
<div class="paragraph">
<p>As with the sequence diagram for non-set-based fields, the above diagram is simplified and omits details about how the test phrase is split into tokens using a new <code>StringTokenizer</code> instance.  "Field" represents any filterable set-based field&#8201;&#8212;&#8201;<code>Tag</code> or <code>Attachment</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Reflection is required here because the <code>makeFilter()</code> method is static, and the correct <code>makeFilter()</code> method has to be chosen at runtime (based on the given field).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The resultant predicates returned by the field-specific parser are then combined based on the given set operator.</p>
</div>
</div>
<div class="sect3">
<h4 id="field-specific-parser"><a class="link" href="#field-specific-parser">Field-specific parser</a></h4>
<div class="paragraph">
<p>As field-specific parsers have to be implemented differently for each filterable field, the design choice was made to place each field-specific parser in its respective field class.  More precisely, each field-specific parser is implemented as a static method (<code>makeFilter()</code>) in its field class.</p>
</div>
<div class="paragraph">
<p>When each filter unit is parsed, it invokes the field-specific parser for the given field identifier.  The field-specific parser then creates and returns a predicate from the given filter operator and test phrase.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Priority values do not compare in the same order as their values as integers.  Priority values have this order (from highest to lowest priority): 1 &gt; 2 &gt; 3 &gt; 4 &gt; 0.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="error-messages"><a class="link" href="#error-messages">Error messages</a></h4>
<div class="paragraph">
<p>As the filter expression syntax can be rather complicated, detecting syntax errors and displaying useful error messages help the user to rectify those errors quickly.  When a parse error is detected, the filter command is designed to the offending token and provides an error message customised for that error.</p>
</div>
<div class="paragraph">
<p>Error conditions are signalled via checked exceptions that inherit from <code>seedu.address.logic.parser.tokenizer.exception.TokenizationException</code>.  Those error conditions that are associated with a particular character range in the filter expression inherit from <code>seedu.address.logic.parser.tokenizer.exception.TokenizationMismatchException</code>, which provides the facilities for storing the start and end indices of the offending character range.  <code>TokenizationMismatchException</code> itself inherits from <code>TokenizationException</code>.  Checked exceptions were chosen because they allow the compiler to enforce that every possible exception is caught, and creating a subclass for each kind of error condition allows for the precise specification (in the <code>throws</code> clause) of the kind of error conditions that can happen in each and every method.</p>
</div>
<div class="paragraph">
<p>The following inheritance diagram shows the inheritance hierarchy of each kind of exception that can be thrown from parsing a filter expression:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FilterParserErrorInheritanceDiagram.png" alt="FilterParserErrorInheritanceDiagram" width="800">
</div>
</div>
<div class="paragraph">
<p>In the diagram above, the blue classes are exceptions thrown by <code>StringTokenizer</code>, while the red classes are exceptions thrown by <code>BooleanExpressionParser</code>.  In order to reduce coupling between <code>StringTokenizer</code> and <code>BooleanExpressionParser</code>, and to be able to distinguish (by type-based <code>catch</code> clauses) the end-of-string exceptions of those components, they do not shared the same class for end-of-string exceptions.</p>
</div>
<div class="paragraph">
<p><code>TokenizationInvalidPredicateException</code> is a wrapper class for <code>InvalidPredicateException</code>, which is thrown when the field-specific parser or set parser encounters an error.  The diagram below shows the different exceptions that may be thrown to indicate the types of issues that may be encountered when parsing a filter unit, and how they may be propagated to <code>FilterCommandParser</code> via wrapping by <code>TokenizationInvalidPredicateException</code>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/FilterParserErrorPredicateInheritanceDiagram.png" alt="FilterParserErrorPredicateInheritanceDiagram" width="800">
</div>
</div>
<div class="paragraph">
<p>The filter unit parser is responsible for constructing a <code>TokenizationInvalidPredicateException</code> from any thrown <code>InvalidPredicateException</code> and associating the <code>TokenizationInvalidPredicateException</code> with the offending character range (which will be one of the three parts (or four, if using the extended set syntax) of the filter unit).</p>
</div>
<div class="paragraph">
<p>Each error message gets translated into a <em>styled</em> message string (encapsulated as <code>ParseException</code>) by <code>FilterCommandParser</code>, and that message string is propagated to the UI via the event system.  The message string is styled such that the offending character range is coloured red and underlined in the <code>ResultDisplay</code> panel that is visible to the user.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In total, there are around 15 distinct kinds of error conditions when parsing a filter expression, and each of these error conditions produce a customised message that is displayed to the user.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="design-considerations"><a class="link" href="#design-considerations">Design Considerations</a></h4>
<div class="sect4">
<h5 id="aspect-how-to-parse-composite-filter-expressions"><a class="link" href="#aspect-how-to-parse-composite-filter-expressions">Aspect: How to parse composite filter expressions</a></h5>
<div class="ulist">
<ul>
<li>
<p><strong>Alternative 1 (current choice):</strong> Use an algorithm that can parse arbitrarily complex expressions (i.e. the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting yard algorithm</a>).</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Provides full flexibility in specifying composite filters.</p>
</li>
<li>
<p>Cons: Difficult to implement.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Alternative 2:</strong> Use a more restrictive parsing algorithm that prohibits parentheses and does not take operator precedence into consideration.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Easy to implement.</p>
</li>
<li>
<p>Cons: Filter command will be limited in expressiveness.  As the order of operations do not follow usual programming languages or mathematical expressions, users need to spend more time to understand the parsing format before use, and they might use the command erroneously.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aspect-whether-to-support-simplified-filter-semantics"><a class="link" href="#aspect-whether-to-support-simplified-filter-semantics">Aspect: Whether to support simplified filter semantics</a></h5>
<div class="ulist">
<ul>
<li>
<p><strong>Alternative 1 (current choice):</strong> Support simplified filter semantics (implicit-AND and any-match).</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Reduces cognitive overhead and typing time for most common cases, and makes <code>filter</code> feel like a standard keyword search function.</p>
</li>
<li>
<p>Cons: Not possible to detect when user accidentally omits the boolean operator or filter field.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Alternative 2:</strong> Only support the unsimplified version.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Easier to implement, can display an error if the user accidentally omits a boolean operator or filter field.</p>
</li>
<li>
<p>Cons: More verbose filter expressions which may require higher cognitive overhead.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aspect-what-the-convenience-operator-should-do"><a class="link" href="#aspect-what-the-convenience-operator-should-do">Aspect: What the convenience operator should do</a></h5>
<div class="ulist">
<ul>
<li>
<p><strong>Alternative 1 (current choice):</strong> Support a convenience operator that is an alias of the most common filter operator for each field.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Reduces cognitive overhead as the convenience operator is usually the expected behaviour for most applications.</p>
</li>
<li>
<p>Cons: Users might be surprised that the convenience operator is an alias for a different operator depending on the field identifier.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Alternative 2:</strong> Support a convenience operator that is an alias of a fixed operator regardless of field.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Easier for users to remember what the convenience operator does.</p>
</li>
<li>
<p>Cons: Convenience operator is not really <em>convenient</em>&#8201;&#8212;&#8201;the behaviour might be surprising or awkward for some fields.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aspect-how-to-signal-exceptional-conditions-when-parsing-filter-expressions"><a class="link" href="#aspect-how-to-signal-exceptional-conditions-when-parsing-filter-expressions">Aspect: How to signal exceptional conditions when parsing filter expressions</a></h5>
<div class="ulist">
<ul>
<li>
<p><strong>Alternative 1 (current choice):</strong> Use a different type of checked exception for every possible type of failure condition.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Every possible failure condition is listed in the <code>throws</code> clause of all methods&#8201;&#8212;&#8201;developers can easily tell how exactly each aspect of parsing could fail, and Java will statically check that every possible failure condition is handled (which makes it impossible to overlook any failure conditions).</p>
</li>
<li>
<p>Cons: Method signatures are more verbose.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Alternative 2:</strong> Use a single checked exception for all possible failure conditions, and distinguish errors by the message string instead.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Less verbose method signatures, and yet the benefit of checked exceptions is retained.</p>
</li>
<li>
<p>Cons: Developers can only tell what exact failure conditions are possible by inspecting the whole call graph of the method.  Furthermore, it is difficult to distinguish different error conditions in order to customize and show relevant messages to the user.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Alternative 3:</strong> Use unchecked exceptions.</p>
<div class="ulist">
<ul>
<li>
<p>Pros: Simplest method signatures.</p>
</li>
<li>
<p>Cons: Easy to overlook possible failure conditions when modifying the code.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div></div><div id="footer"><div class="container"><div id="footer-text">Last updated 2018-11-07 09:38:28 UTC</div></div></div></body></html>